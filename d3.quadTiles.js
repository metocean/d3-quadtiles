// Generated by CoffeeScript 1.9.2
var mercatorφ, noop;

noop = function() {};

mercatorφ = function(y) {
  return Math.atan(Math.exp(-y * Math.PI / 180)) * 360 / Math.PI - 90;
};

module.exports = d3.quadTiles = function(projection, zoom) {
  var invisible, precision, step, stream, tiles, visit, width;
  tiles = [];
  invisible = null;
  zoom = Math.max(0, zoom);
  width = Math.pow(2, zoom);
  step = Math.max(.2, Math.min(1, zoom * .01));
  precision = projection.precision();
  stream = projection.precision(960).stream({
    point: function() {
      return invisible = false;
    },
    lineStart: noop,
    lineEnd: noop,
    polygonStart: noop,
    polygonEnd: noop
  });
  visit = function(x1, y1, x2, y2) {
    var i, j, k, l, m1, m2, ref, ref1, ref10, ref11, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, w, x, y, δ;
    w = x2 - x1;
    m1 = mercatorφ(y1);
    m2 = mercatorφ(y2);
    δ = step * w;
    invisible = true;
    stream.polygonStart();
    stream.lineStart();
    for (x = i = ref = x1, ref1 = x2 + δ / 2, ref2 = δ; ref2 > 0 ? i < ref1 : i > ref1; x = i += ref2) {
      if (!invisible) {
        break;
      }
      stream.point(x, m1);
    }
    for (y = j = ref3 = m1, ref4 = m2 + δ / 2, ref5 = δ; ref5 > 0 ? j < ref4 : j > ref4; y = j += ref5) {
      if (!invisible) {
        break;
      }
      stream.point(x2, y);
    }
    for (x = k = ref6 = x2, ref7 = x1 - δ / 2, ref8 = -δ; ref8 > 0 ? k < ref7 : k > ref7; x = k += ref8) {
      if (!invisible) {
        break;
      }
      stream.point(x, m2);
    }
    for (y = l = ref9 = m2, ref10 = m1 - δ / 2, ref11 = -δ; ref11 > 0 ? l < ref10 : l > ref10; y = l += ref11) {
      if (!invisible) {
        break;
      }
      stream.point(x1, y);
    }
    if (invisible) {
      stream.point(x1, m1);
    }
    stream.lineEnd();
    stream.polygonEnd();
    if (invisible) {
      return;
    }
    if (w <= 360 / width) {
      return tiles.push({
        type: 'Polygon',
        coordinates: [
          d3.range(x1, x2 + δ / 2, δ).map(function(x) {
            return [x, y1];
          }).concat([[x2, .5 * (y1 + y2)]]).concat(d3.range(x2, x1 - (δ / 2), -δ).map(function(x) {
            return [x, y2];
          })).concat([[x1, .5 * (y1 + y2)]]).concat([[x1, y1]]).map(function(d) {
            return [d[0], mercatorφ(d[1])];
          })
        ],
        key: [(180 + x1) / 360 * width | 0, (180 + y1) / 360 * width | 0, zoom],
        centroid: [.5 * (x1 + x2), .5 * (m1 + m2)]
      });
    } else {
      x = .5 * (x1 + x2);
      y = .5 * (y1 + y2);
      visit(x1, y1, x, y);
      visit(x, y1, x2, y);
      visit(x1, y, x, y2);
      return visit(x, y, x2, y2);
    }
  };
  visit(-180, -180, 180, 180);
  projection.precision(precision);
  return tiles;
};
