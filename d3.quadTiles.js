// Generated by CoffeeScript 1.9.2
var mercatorφ, noop;

noop = function() {};

mercatorφ = function(y) {
  return Math.atan(Math.exp(-y * Math.PI / 180)) * 360 / Math.PI - 90;
};

module.exports = d3.quadTiles = function(projection, zoom) {
  var extent, precision, step, stream, tiles, visible, visit, width;
  tiles = [];
  visible = null;
  zoom = Math.max(0, zoom);
  width = Math.pow(2, zoom);
  step = Math.max(.2, Math.min(1, zoom * .01));
  precision = projection.precision();
  extent = projection.clipExtent();
  stream = projection.precision(960).stream({
    point: function() {
      return visible = true;
    },
    lineStart: noop,
    lineEnd: noop,
    polygonStart: noop,
    polygonEnd: noop
  });
  visit = function(x1, y1, x2, y2) {
    var m1, m2, p1, p2, p3, p4, run, w, x, y, δ;
    w = x2 - x1;
    m1 = mercatorφ(y1);
    m2 = mercatorφ(y2);
    δ = step * w;
    visible = false;
    run = function(a, b) {
      var results, results1, results2, results3, x, y;
      if (visible) {
        return;
      }
      x = a[0];
      y = a[1];
      if (a[0] < b[0]) {
        if (a[1] < b[1]) {
          results = [];
          while (x <= b[0] && y <= b[1] && !visible) {
            stream.point(x, y);
            x += δ;
            results.push(y += δ);
          }
          return results;
        } else {
          results1 = [];
          while (x <= b[0] && y >= b[1] && !visible) {
            stream.point(x, y);
            x += δ;
            results1.push(y -= δ);
          }
          return results1;
        }
      } else {
        if (a[1] < b[1]) {
          results2 = [];
          while (x >= b[0] && y <= b[1] && !visible) {
            stream.point(x, y);
            x -= δ;
            results2.push(y += δ);
          }
          return results2;
        } else {
          results3 = [];
          while (x >= b[0] && y >= b[1] && !visible) {
            stream.point(x, y);
            x -= δ;
            results3.push(y -= δ);
          }
          return results3;
        }
      }
    };
    p1 = [x1, m1];
    p2 = [x2, m1];
    p3 = [x2, m2];
    p4 = [x1, m2];
    if (!visible) {
      stream.polygonStart();
      stream.lineStart();
      run(p1, p2);
      run(p2, p3);
      run(p3, p4);
      run(p4, p1);
      stream.lineEnd();
      stream.polygonEnd();
    }
    if (!visible) {
      stream.polygonStart();
      stream.lineStart();
      run(p1, p2);
      run(p2, p3);
      run(p3, p1);
      stream.lineEnd();
      stream.polygonEnd();
    }
    if (!visible) {
      stream.polygonStart();
      stream.lineStart();
      run(p1, p3);
      run(p3, p4);
      run(p4, p1);
      stream.lineEnd();
      stream.polygonEnd();
    }
    if (!visible) {
      return;
    }
    if (w <= 360 / width) {
      return tiles.push({
        type: 'Polygon',
        coordinates: [
          [].concat(d3.range(x1, x2 + δ / 2, δ).map(function(x) {
            return [x, y1];
          })).concat([[x2, .5 * (y1 + y2)]]).concat(d3.range(x2, x1 - (δ / 2), -δ).map(function(x) {
            return [x, y2];
          })).concat([[x1, .5 * (y1 + y2)]]).concat([[x1, y1]]).map(function(d) {
            return [d[0], mercatorφ(d[1])];
          })
        ],
        key: [(180 + x1) / 360 * width | 0, (180 + y1) / 360 * width | 0, Math.log2(360 / w)],
        centroid: [.5 * (x1 + x2), mercatorφ(.5 * (y1 + y2))]
      });
    } else {
      x = .5 * (x1 + x2);
      y = .5 * (y1 + y2);
      visit(x1, y1, x, y);
      visit(x, y1, x2, y);
      visit(x1, y, x, y2);
      return visit(x, y, x2, y2);
    }
  };
  visit(-180, -180, 180, 180);
  projection.precision(precision);
  return tiles;
};
