// Generated by CoffeeScript 1.9.2
var square, subdivide, tiletolnglat;

tiletolnglat = function(x, y, z) {
  var n;
  n = Math.PI - 2 * Math.PI * y / Math.pow(2, z);
  return [x / Math.pow(2, z) * 360 - 180, 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)))];
};

subdivide = function(a, b, n, f) {
  var dx, dy, i, j, k, len, ref, results, results1, x, y;
  x = a[0];
  dx = a[0] === b[0] ? 0 : b[0] - a[0];
  y = a[1];
  dy = a[1] === b[1] ? 0 : b[1] - a[1];
  ref = (function() {
    results1 = [];
    for (var k = 0; 0 <= n ? k < n : k > n; 0 <= n ? k++ : k--){ results1.push(k); }
    return results1;
  }).apply(this).map(function(i) {
    return i / n;
  });
  results = [];
  for (j = 0, len = ref.length; j < len; j++) {
    i = ref[j];
    results.push(f([x + i * dx, y + i * dy]) === true);
  }
  return results;
};

square = function(x, y) {
  return [[x, y], [x + 1, y], [x + 1, y + 1], [x, y + 1]];
};

module.exports = d3.quadTiles = function(projection, options) {
  var dive, extent, fin, precision, projecttile, stream, tiles, visible, zoom;
  if (options == null) {
    options = {};
  }
  if (options.maxtiles == null) {
    options.maxtiles = 16;
  }
  if (options.maxzoom == null) {
    options.maxzoom = 18;
  }
  precision = projection.precision();
  extent = projection.clipExtent();
  visible = false;
  stream = projection.precision(960).stream({
    point: function() {
      return visible = true;
    },
    lineStart: function() {},
    lineEnd: function() {},
    polygonStart: function() {},
    polygonEnd: function() {}
  });
  projecttile = function(x, y, z) {
    var check, coords, p;
    p = square(x, y);
    coords = [];
    visible = false;
    stream.polygonStart();
    stream.lineStart();
    check = function(i) {
      var o;
      o = tiletolnglat(i[0], i[1], z);
      stream.point(o[0], o[1]);
      return coords.push(o);
    };
    subdivide(p[0], p[1], 10, check);
    subdivide(p[1], p[2], 10, check);
    subdivide(p[2], p[3], 10, check);
    subdivide(p[3], p[0], 10, check);
    stream.lineEnd();
    stream.polygonEnd();
    if (!visible) {
      return null;
    }
    return coords;
  };
  fin = false;
  tiles = [
    {
      tile: [0, 0],
      coords: projecttile(0, 0, 0)
    }
  ];
  zoom = 0;
  dive = function() {
    var coords, gen1, gen2, j, k, len, len1, nexttiles, ref;
    nexttiles = [];
    for (j = 0, len = tiles.length; j < len; j++) {
      gen1 = tiles[j];
      ref = square(gen1.tile[0] * 2, gen1.tile[1] * 2);
      for (k = 0, len1 = ref.length; k < len1; k++) {
        gen2 = ref[k];
        coords = projecttile(gen2[0], gen2[1], zoom + 1);
        if (coords == null) {
          continue;
        }
        nexttiles.push({
          tile: gen2,
          coords: coords
        });
      }
    }
    if (nexttiles.length > options.maxtiles) {
      fin = true;
      return;
    }
    tiles = nexttiles;
    return zoom++;
  };
  while (!fin && zoom <= options.maxzoom) {
    dive();
  }
  tiles = tiles.map(function(tile) {
    return {
      type: 'Polygon',
      coordinates: [tile.coords],
      key: [tile.tile[0], tile.tile[1], zoom],
      centroid: tiletolnglat(tile.tile[0] + 0.5, tile.tile[1] + 0.5, zoom)
    };
  });
  projection.precision(precision);
  projection.clipExtent(extent);
  return {
    zoom: zoom,
    tiles: tiles
  };
};
