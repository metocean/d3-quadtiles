// Generated by CoffeeScript 1.9.2
var d3, projecttile, square, subdivideline, tiletolnglat;

d3 = require('d3');

tiletolnglat = require('tiletolnglat');

subdivideline = require('subdivideline');

square = function(x, y) {
  return [[x, y], [x + 1, y], [x + 1, y + 1], [x, y + 1]];
};

projecttile = function(x, y, z) {
  var calc, coords, p;
  p = square(x, y);
  coords = [];
  calc = function(i) {
    return coords.push(tiletolnglat(i[0], i[1], z));
  };
  subdivideline(p[0], p[1], 10, calc);
  subdivideline(p[1], p[2], 10, calc);
  subdivideline(p[2], p[3], 10, calc);
  subdivideline(p[3], p[0], 10, calc);
  return coords;
};

module.exports = d3.quadTiles = function(projection, options) {
  var alltiles, currenttiles, dive, extent, fin, isvisible, precision, stream, visible, zoom;
  if (options == null) {
    options = {};
  }
  if (options.maxtiles == null) {
    options.maxtiles = 16;
  }
  if (options.maxzoom == null) {
    options.maxzoom = 18;
  }
  precision = projection.precision();
  extent = projection.clipExtent();
  visible = false;
  stream = projection.precision(960).stream({
    point: function() {
      return visible = true;
    },
    lineStart: function() {},
    lineEnd: function() {},
    polygonStart: function() {},
    polygonEnd: function() {}
  });
  isvisible = function(x, y, z) {
    var check, p;
    p = square(x, y);
    visible = false;
    stream.polygonStart();
    stream.lineStart();
    check = function(i) {
      var o;
      o = tiletolnglat(i[0], i[1], z);
      return stream.point(o[0], o[1]);
    };
    subdivideline(p[0], p[1], 10, check);
    subdivideline(p[1], p[2], 10, check);
    subdivideline(p[2], p[3], 10, check);
    subdivideline(p[3], p[0], 10, check);
    stream.lineEnd();
    stream.polygonEnd();
    return visible;
  };
  fin = false;
  currenttiles = [[0, 0]];
  alltiles = [];
  alltiles.push(currenttiles);
  zoom = 0;
  dive = function() {
    var gen1, gen2, j, k, len, len1, nexttiles, ref;
    nexttiles = [];
    for (j = 0, len = currenttiles.length; j < len; j++) {
      gen1 = currenttiles[j];
      ref = square(gen1[0] * 2, gen1[1] * 2);
      for (k = 0, len1 = ref.length; k < len1; k++) {
        gen2 = ref[k];
        if (!isvisible(gen2[0], gen2[1], zoom + 1)) {
          continue;
        }
        nexttiles.push(gen2);
      }
    }
    if (nexttiles.length > options.maxtiles) {
      fin = true;
      return;
    }
    currenttiles = nexttiles;
    alltiles.push(nexttiles);
    return zoom++;
  };
  while (!fin && zoom <= options.maxzoom) {
    dive();
  }
  alltiles = alltiles.map(function(tiles, z) {
    return tiles.map(function(tile) {
      return {
        type: 'Polygon',
        key: [tile[0], tile[1], z],
        coordinates: [projecttile(tile[0], tile[1], z)],
        centroid: tiletolnglat(tile[0] + 0.5, tile[1] + 0.5, z)
      };
    });
  });
  projection.precision(precision);
  projection.clipExtent(extent);
  return {
    zoom: zoom,
    tiles: alltiles[zoom],
    all: alltiles
  };
};
